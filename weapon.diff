diff --git a/ANSWERS.md b/ANSWERS.md
index c6306c3..abb641b 100644
--- a/ANSWERS.md
+++ b/ANSWERS.md
@@ -22,11 +22,27 @@ Sinon la  lave resmenle un peu au pieces car c'est un objet amovible qui a une i
 
 # Semaine 4
 
-### Question 1 (Paul)
-### Question 2 (Paul)
-### Question 3 (Paul)
+### Question 1 (Paul) :Quelles formules utilisez-vous exactement pour l’épée ? Comment passez-vous des coordonnées écran aux coordonnées monde ?
+j'utillise cette formule pour calculer la difference entre la position de la souris et celle de la joueuse
+    delta_x=mouse_x+self.__camera.bottom_left.x-self.__player.center_x
+    delta_y=mouse_y+self.__camera.bottom_left.y-self.__player.center_y-5
+ensuite j'utilise l'arctangente (atan2(delta_x,delta_y)) pour calculer l'angle
+
+les coordonees de l'ecran commencent en bas a gauche donc j'utilise les coordonees point en bas a gauche de la camera auquelle j'ajoute les coordone de la souris pour passer au coordonée monde
+
+
+### Question 2 (Paul) :
+
+
+
+### Question 3 (Paul) :Où le remettez-vous à zéro ? Avez-vous du code dupliqué entre les cas où la joueuse perd parce qu’elle a touché un ou monstre ou de la lave ?
+le score est initialiser en meme temps que la joueuse du coup il est remis a zero lors de l'inintialisation
+
+
 ### Question 4 (Paul)
 
+
+
 ### Question 5 (Gaëlle) : Comment modélisez-vous la “next-map” ? Où la stockez-vous, et comment la traitez-vous quand la joueuse atteint le point E ?
 
 La next map est le chemin du prochain niveau, qui est stocké comme string dans un attribut de la class GameView. Cet attribut est mis à jour à chauque fois qu'une nouvelle map est crée par la méthode create_map(). Quand la joueuse atteint le point E, la méthode load_next_map() est appelée. Cette méthode s'assure que le nom de la prochaine map est bien stockée, puis remplace la map actuelle par la prochaine map dans l'attribut current_map_name, avant d'appeler la méthode setup qui crée le prochain niveau. 
diff --git a/LOG.md b/LOG.md
index cacfc12..0cd91e4 100644
--- a/LOG.md
+++ b/LOG.md
@@ -23,10 +23,8 @@ Mettez ici ce que vous pensez devoir être la ou les 2 prochaines étapes pour c
 * [] Test lave
 
 * [] ANSWERS.MD (deux dernières questions, semaine 3)
-* [] Coin counter
 * [] Test coin counter
 * [] Test player death
-* [] Epée
 * [] Test épée
 * [] ANSWERS.MD (4 premieres ?, semaine 4)
 * [] Bow and arrow
@@ -70,7 +68,7 @@ Mettez ici ce que vous pensez devoir être la ou les 2 prochaines étapes pour c
 * [x] Encapsulation, modularisation et réorganisation du code        180    
 * [x] ANSWERS.MD (deux premières questions)                           20 
 * [x] ANSWERS.MD (deux dernières questions)                           10
-* [x] Epée                                                           200
+* 
 
 ### Semaine 4
 
@@ -81,6 +79,8 @@ Mettez ici ce que vous pensez devoir être la ou les 2 prochaines étapes pour c
 * [x] Tuple pour rentre le match dans create map plus lisible         40
 
 ### Semaine 5
+* [x] Coin counter                                                    15
+* [x] Epée                                                           200
 
 ### Semaine 6
 
diff --git a/arrow.py b/arrow.py
new file mode 100644
index 0000000..107e4df
--- /dev/null
+++ b/arrow.py
@@ -0,0 +1,31 @@
+import arcade 
+import constants
+import math_personaliser
+from bow import Bow
+
+
+ARROW_SPEED = 20
+ARROW_GRAVITY = 1
+
+class Arrow(arcade.Sprite):
+    def __init__(self, bow: Bow, player_x_speed: float, player_y_speed: float) -> None :
+        
+        super().__init__("assets/kenney-voxel-items-png/arrow.png", constants.SCALE*0.7)
+        self.angle = bow.angle+bow.texture_angle
+        self.center_x = bow.center_x
+        self.center_y = bow.center_y
+        self.change_x = player_x_speed+ARROW_SPEED*math_personaliser.sin_deg(self.angle)
+        self.change_y = player_y_speed+ARROW_SPEED*math_personaliser.cos_deg(self.angle)
+        
+    def move(self) -> None :
+        self.change_y -= ARROW_GRAVITY
+        self.center_x += self.change_x
+        self.center_y += self.change_y
+        self.angle = math_personaliser.atan2_deg_aprox(self.change_x,self.change_y)-45
+        
+
+    
+
+
+
+        
\ No newline at end of file
diff --git a/bat.py b/bat.py
index 8dfbc56..83cf370 100644
--- a/bat.py
+++ b/bat.py
@@ -75,6 +75,8 @@ class Bat(Monster):
         """
         x_speed = math.cos(math.radians(angle__deg)) * BAT_SPEED
         y_speed = math.sin(math.radians(angle__deg)) * BAT_SPEED
+        if x_speed*self.scale_x > 0.5  :
+            self.scale_x *= -1
 
         return (x_speed, y_speed)
 
diff --git a/blob.py b/blob.py
index 47020f4..0e824ec 100644
--- a/blob.py
+++ b/blob.py
@@ -3,7 +3,7 @@ import constants
 from monster import Monster
 
 """Speed of the blue blobs"""
-BLUE_BLOB_SPEED = 2
+BLUE_BLOB_SPEED = -2
 
 class Blob(Monster):
     """Represents a blob, how it moves and checks for collistions"""
@@ -34,4 +34,4 @@ class Blob(Monster):
         # Checks if blob is on the edge of the platform or if it is touching a wall other than the floor underneath it
         if arcade.check_for_collision_with_list(self, wall_list) != [] or is_on_edge:
             self.speed = -self.speed
-            self.texture.flip_left_right
\ No newline at end of file
+            self.scale_x *= -1
diff --git a/bow.py b/bow.py
new file mode 100644
index 0000000..2d13d28
--- /dev/null
+++ b/bow.py
@@ -0,0 +1,30 @@
+import arcade
+import constants
+from weapon import Weapon
+
+
+
+class Bow(Weapon):
+    """define how the sword work """
+
+    def __init__(self, delta_x: float, delta_y: float ,player_x: float ,player_y: float) -> None :
+        super().__init__("assets/kenney-voxel-items-png/bow.png", constants.SCALE*0.7)
+        Weapon.set_texture_angle(self, 135)
+        Weapon.set_angle(self, delta_x, delta_y)
+        Weapon.update_position(self, player_x, player_y)
+        self.time = 0
+        self.charged = False
+        #Sword.start(delta_x, delta_y, player_x, player_y)
+    
+    def can_shoot_arrow(self) -> None :
+        TIMMER = 15
+        if TIMMER < self.time:
+           #arcade.Sprite.texture.fset(self, "assets/kenney-voxel-items-png/bow.png")
+           self.texture = arcade.load_texture("assets/kenney-voxel-items-png/bowArrow.png")
+           self.angle += 90
+           Weapon.set_texture_angle(self, 45)
+           
+           self.charged = True
+           
+    
+    
diff --git a/gameview.py b/gameview.py
index d35c166..b7ac082 100644
--- a/gameview.py
+++ b/gameview.py
@@ -6,8 +6,11 @@ from player import Player
 from blob import Blob
 from monster import Monster
 from weapon import Weapon
+from sword import Sword
+from bow import Bow
 from pyglet.graphics import Batch
 from bat import Bat
+from arrow import Arrow
 
 
 class GameView(arcade.View):
@@ -17,7 +20,9 @@ class GameView(arcade.View):
     __wall_list: arcade.SpriteList[arcade.Sprite]
     __lava_list: arcade.SpriteList[arcade.Sprite]
     __coin_list: arcade.SpriteList[arcade.Sprite]
-    __weapon_list: arcade.SpriteList[Weapon]
+    __sword_list: arcade.SpriteList[Sword]
+    __bow_list: arcade.SpriteList[Bow]
+    __arrow_list: arcade.SpriteList[Arrow]
     __monster_list: arcade.SpriteList[Monster]
     __end_list: arcade.SpriteList[arcade.Sprite]
     physics_engine: arcade.PhysicsEnginePlatformer
@@ -148,11 +153,13 @@ class GameView(arcade.View):
         self.__coin_list = arcade.SpriteList(use_spatial_hash=True)
         self.__lava_list = arcade.SpriteList(use_spatial_hash=True)
         self.__monster_list = arcade.SpriteList()
-        self.__weapon_list = arcade.SpriteList()
+        self.__sword_list = arcade.SpriteList()
+        self.__bow_list = arcade.SpriteList()
+        self.__arrow_list = arcade.SpriteList()
         self.__end_list = arcade.SpriteList(use_spatial_hash=True)
 
         self.sprite_tuple = (self.player_sprite_list, self.__wall_list, self.__coin_list, self.__lava_list,
-                            self.__monster_list, self.__weapon_list, self.__end_list) 
+                            self.__monster_list, self.__sword_list, self.__bow_list, self.__arrow_list, self.__end_list) 
 
         self.__create_map()
                 
@@ -195,25 +202,49 @@ class GameView(arcade.View):
             match button:
                 case arcade.MOUSE_BUTTON_LEFT:
                     """calclule la difference x et y entre la souris et le joueur"""
-                    delta_x=mouse_x+self.__camera.bottom_left.x-self.__player.center_x
-                    delta_y=mouse_y+self.__camera.bottom_left.y-self.__player.center_y-5
-                    weapon = Weapon(delta_x, delta_y, self.__player.center_x ,self.__player.center_y)
-                    self.__weapon_list.append(weapon)
-                    #weapon = Weapon.__init__(angle)
-                    #self.__weapon_list.append(weapon)
+                    delta_x=mouse_x+self.__camera.bottom_left.x-self.player_x
+                    delta_y=mouse_y+self.__camera.bottom_left.y-self.player_y-5
+                    """
+                    match self.player_weapon:
+                        case "sword":
+                            weapon = Sword(delta_x, delta_y, self.player_x ,self.player_y)
+                            self.weapon_list.append(weapon)
+                        case "bow":
+                            weapon = Bow(delta_x, delta_y, self.player_x ,self.player_y)
+                            self.weapon_list.append(weapon)
+                        """
+                    if self.player_weapon == "sword":
+                        sword = Sword(delta_x, delta_y, self.player_x ,self.player_y)
+                        self.__sword_list.append(sword)
+                    if self.player_weapon == "bow":
+                        bow = Bow(delta_x, delta_y, self.player_x ,self.player_y)
+                        self.__bow_list.append(bow)
+
+
+                case arcade.MOUSE_BUTTON_RIGHT:
+                    """change d'arme equiper"""
+                    Player.change_weapon(self.__player)
+                        
                                   
     def on_mouse_release(self, mouse_x: int, mouse_y: int, button: int, modifiers: int) -> None:
         match button:
             case arcade.MOUSE_BUTTON_LEFT:
-                for weapon in self.__weapon_list:
-                        weapon.remove_from_sprite_lists()
+                for bow in self.__bow_list:
+                    if bow.charged  :
+                        arrow = Arrow(bow, self.player_speed_x, self.player_speed_y)
+                        self.__arrow_list.append(arrow)
+                        Arrow.move(arrow)
+                self.__sword_list.clear()
+                self.__bow_list.clear()
 
     def on_mouse_motion(self, mouse_x: int, mouse_y: int, _buttons: int, _modifiers: int) -> None:
         """calclule la difference x et y entre la souris et le joueur"""
         delta_x=mouse_x+self.__camera.bottom_left.x-self.__player.center_x
         delta_y=mouse_y+self.__camera.bottom_left.y-self.__player.center_y-5
-        for weapon in self.__weapon_list:
-            Weapon.set_angle(weapon, delta_x, delta_y)
+        for sword in self.__sword_list:
+            Weapon.set_angle(sword, delta_x, delta_y)
+        for bow in self.__bow_list:
+            Weapon.set_angle(bow, delta_x, delta_y)
 
     def on_update(self, delta_time: float) -> None:
         """Called once per frame, before drawing.
@@ -225,12 +256,23 @@ class GameView(arcade.View):
         for monster in self.__monster_list :
             monster.move(self.__wall_list)
         
-        for weapon in self.__weapon_list:
-            Weapon.move(weapon, self.__player.center_x ,self.__player.center_y)
-        
+        for bow in self.__bow_list:
+                Weapon.update_position(bow, self.__player.center_x ,self.__player.center_y)
+                Weapon.time_counting(bow)
+                if not bow.charged:
+                    Bow.can_shoot_arrow(bow)      
+
+        for sword in self.__sword_list:
+            Weapon.update_position(sword, self.__player.center_x ,self.__player.center_y)
+            Weapon.time_counting(sword)
+
+        for arrow in self.__arrow_list :
+            arrow.move()
+
         self.physics_engine.update()
         self.__update_camera()
         self.__check_collisions()
+        
             
     def __update_camera(self) -> None :
         """Updates camera position when player moves/dies"""
@@ -258,15 +300,31 @@ class GameView(arcade.View):
 
         for coin in arcade.check_for_collision_with_list(self.__player, self.__coin_list) :
             coin.remove_from_sprite_lists()
-            Player.coin_score_update(self.__player, 1)
-            arcade.play_sound(arcade.load_sound(":resources:sounds/coin5.wav"))
-
-        for weapon in self.__weapon_list:
-           if Weapon.hit_frame(weapon, 5):
-                for monster in arcade.check_for_collision_with_list(weapon, self.__monster_list) :
+            Player.coin_score_update(self.__player)
+            arcade.play_sound(arcade.load_sound(":resources:sounds/coin5.wav"))            
+                                                                            
+        for arrow in self.__arrow_list :
+            for monster_hit in arcade.check_for_collision_with_list(arrow, self.__monster_list) :
+                for monster in arcade.check_for_collision_with_list(arrow, self.__monster_list) :
+                    Monster.die(monster)
+                    arrow.remove_from_sprite_lists()
+                    arcade.play_sound(arcade.load_sound(":resources:sounds/hurt4.wav")) 
+                #arrow.remove_from_sprite_lists()
+                arcade.play_sound(arcade.load_sound(":resources:sounds/coin5.wav"))
+            for wall_hit in arcade.check_for_collision_with_list(arrow, self.__wall_list) :
+                arrow.remove_from_sprite_lists()
+                arcade.play_sound(arcade.load_sound(":resources:sounds/coin5.wav"))
+
+           
+        for sword in self.__sword_list:
+            if Sword.hit_frame(sword, 5):
+                for monster in arcade.check_for_collision_with_list(sword, self.__monster_list) :
                     monster.die()
                     arcade.play_sound(arcade.load_sound(":resources:sounds/hurt4.wav"))
 
+                
+
+
         if arcade.check_for_collision_with_list(self.__player, self.__lava_list) != [] :
             self.__setup_from_initial()
         if arcade.check_for_collision_with_list(self.__player, self.__monster_list) != [] :
@@ -317,6 +375,10 @@ class GameView(arcade.View):
     def player_speed_y(self) -> float:
         return self.__player.change_y
     
+    @property
+    def player_weapon(self) -> str:
+        return self.__player.equiped_weapon
+    
     @property
     def camera_x(self) -> float:
         return self.__camera.center_left.x
diff --git a/maps/testing_maps/blob_test_map.txt b/maps/testing_maps/blob_test_map.txt
new file mode 100644
index 0000000..f5c3406
--- /dev/null
+++ b/maps/testing_maps/blob_test_map.txt
@@ -0,0 +1,6 @@
+width: 20
+height: 2
+---
+ S* x * x * x * o * 
+====================
+---
\ No newline at end of file
diff --git a/math_personaliser.py b/math_personaliser.py
new file mode 100644
index 0000000..cd4f049
--- /dev/null
+++ b/math_personaliser.py
@@ -0,0 +1,39 @@
+import math
+
+def atan2_deg_aprox(x: float, y: float) -> float:
+    """use the symetries of arctan"""
+    if x == 0 and y == 0:
+        return 45   #take care of the case x=y=0
+    s_x = x > 0     #x is positive
+    s_y = y > 0     #y is positive
+    c_xy = abs(x) > abs(y)    # x is gerater than y
+    if s_y:
+        if s_x:
+            if c_xy:
+                return 90-tan_deg_aprox(y/x)
+            return tan_deg_aprox(x/y)
+        if c_xy:
+            return -90+tan_deg_aprox(-y/x)
+        return -tan_deg_aprox(-x/y)
+    if s_x:
+        if c_xy:
+            return 90+tan_deg_aprox(-y/x)
+        return 180-tan_deg_aprox(-x/y)
+    if c_xy:
+        return -90-tan_deg_aprox(y/x)
+    return -180+tan_deg_aprox(x/y)
+    
+def tan_deg_aprox(x: float) -> float:
+    return (-15.5450048923999*x+60.7150688287897)*x
+
+
+def atan2_deg(x: float,y: float) -> float:
+    return math.atan2(x,y)*180/math.pi
+
+def sin_deg(x: float) -> float:
+    return math.sin(x*math.pi/180)
+
+def cos_deg(x: float) -> float:
+    return math.cos(x*math.pi/180)
+
+
diff --git a/player.py b/player.py
index 88bea77..97298f8 100644
--- a/player.py
+++ b/player.py
@@ -9,15 +9,19 @@ class Player(arcade.Sprite):
     Manages its movements, animations and interactions with the world.
     """
 
+
+
     physics_engine : arcade.PhysicsEnginePlatformer | None
 
     def __init__(self, x: float, y: float) -> None :
         super().__init__(":resources:images/animated_characters/female_adventurer/femaleAdventurer_idle.png", constants.SCALE)
         self.physics_engine = None
-
         self.center_x = x
         self.center_y = y
         self.coin_score=0
+        self.weapon_type_list = ["sword" , "bow"]   #need to not be empty
+        self.equiped_weapon_id = 0
+        self.equiped_weapon = self.weapon_type_list[self.equiped_weapon_id]
 
     is_going_left = False
     is_going_right = False
@@ -27,8 +31,12 @@ class Player(arcade.Sprite):
     allow_multi_jump = False
     allowed_jumps = 1
 
-    def coin_score_update (self, coin :int) -> None:
-        self.coin_score += coin
+    def coin_score_update (self) -> None:
+        self.coin_score += 1
+
+    def change_weapon(self) -> None:
+        self.equiped_weapon_id = (self.equiped_weapon_id+1)%len(self.weapon_type_list)
+        self.equiped_weapon = self.weapon_type_list[self.equiped_weapon_id]
 
     def on_key_press(self, key: int, modifiers: int) -> None:
         """
@@ -78,4 +86,5 @@ class Player(arcade.Sprite):
                 else :
                     self.change_x = constants.PLAYER_MOVEMENT_SPEED
 
+
     
\ No newline at end of file
diff --git a/sword.py b/sword.py
new file mode 100644
index 0000000..5d3169d
--- /dev/null
+++ b/sword.py
@@ -0,0 +1,22 @@
+import arcade
+import constants
+from weapon import Weapon
+
+class Sword(Weapon):
+    """define how the sword work """
+
+    def __init__(self, delta_x: float, delta_y: float ,player_x: float ,player_y: float) -> None :
+        super().__init__("assets/kenney-voxel-items-png/sword_silver.png", constants.SCALE*0.7)
+        Weapon.set_texture_angle(self, 45)
+        Weapon.set_angle(self, delta_x, delta_y)
+        Weapon.update_position(self, player_x, player_y)
+        self.time = 0
+        self.rgb =255, 0, 0
+        self.texture_angle =45
+        #Sword.start(delta_x, delta_y, player_x, player_y)
+        
+    def hit_frame(self, timer: int) -> bool :
+        if timer < self.time:
+            self.rgb = 255 ,255 ,255
+            return False
+        return True
diff --git a/weapon.py b/weapon.py
index eabb589..02a9ec0 100644
--- a/weapon.py
+++ b/weapon.py
@@ -1,38 +1,33 @@
 import arcade
 import constants
 import math
-from player import Player
+import math_personaliser
+
 
 
 class Weapon(arcade.Sprite):
+
+    time = 0
     """define how the weapon work and calculate it's movement"""
-    def __init__(self, delta_x: float, delta_y: float ,player_x: float ,player_y: float) -> None :
-        super().__init__("assets/kenney-voxel-items-png/sword_silver.png", constants.SCALE*0.7)
-        self.set_angle(delta_x, delta_y)
-        self.update_position(player_x, player_y)
-        self.time = 0
-        self.rgb =255, 0, 0
-
-    def move(self, player_x: float, player_y :float) -> None :
-        self.update_position(player_x, player_y)
-
-    def hit_frame(self, timer: int) -> bool :
-        self.time +=1
-        if timer < self.time:
-            self.rgb = 255 ,255 ,255
-            return False
-        return True
+    def set_texture_angle(self, angle_texture: float) -> None :
+        self.texture_angle = angle_texture
+
+
+    def time_counting(self) -> None :
+        self.time += 1
 
     def set_angle(self, delta_x: float, delta_y: float) -> None :
-        self.angle_rad = math.atan2(delta_x, delta_y)
-        self.angle = self.angle_rad*(180/math.pi)-45
+        #self.angle_rad = math.atan2(delta_x, delta_y)
+        #self.angle = self.angle_rad*(180/math.pi)-45 
+        self.angle = math_personaliser.atan2_deg(delta_x, delta_y)-self.texture_angle
+
 
     def update_position(self, player_x: float, player_y: float) -> None :
-        DISTANCE_EPEE_JOUEUR = 30 #
+        DISTANCE_ARME_JOUEUR = 25 
         DELTA_H = 5
         
-        self.center_x = player_x+DISTANCE_EPEE_JOUEUR*math.sin(self.angle_rad)
-        self.center_y = player_y+DISTANCE_EPEE_JOUEUR*math.cos(self.angle_rad)-DELTA_H
+        self.center_x = player_x+DISTANCE_ARME_JOUEUR*math_personaliser.sin_deg(self.angle+self.texture_angle)
+        self.center_y = player_y+DISTANCE_ARME_JOUEUR*math_personaliser.cos_deg(self.angle+self.texture_angle)-DELTA_H
 
 
     
